package task

import (
	"strings"
	"time"
)

// TaskType represents the inferred classification of a task
// Used to determine loot drop tables (design.md ยง6)
type TaskType string

const (
	TaskTypeAdmin          TaskType = "admin"           // operational, short tasks
	TaskTypeMaintenance    TaskType = "maintenance"     // recurring upkeep
	TaskTypePlanning       TaskType = "planning"        // thinking tasks
	TaskTypeDeepWork       TaskType = "deep_work"       // long, finite creation
	TaskTypePerpetualFlow  TaskType = "perpetual_flow"  // never-ending inflow
	TaskTypeCleanup        TaskType = "cleanup"         // recovery/backlog
)

// InferType classifies a task based on its properties
// Inference rules from design.md ยง6:
// - Admin: short, operational, often tagged
// - Maintenance: recurring with moderate intervals
// - Planning: tagged planning/review/brainstorm
// - Deep Work: long duration, finite, creation-oriented
// - Perpetual Flow: high-frequency recurring (daily/hourly)
// - Cleanup: generated by system or zombie-related
func (t *Task) InferType() TaskType {
	// Cleanup: if task has zombie tag or cleanup-related keywords
	if t.HasTag("cleanup") || t.HasTag("zombie") || 
		strings.Contains(strings.ToLower(t.Name), "cleanup") ||
		strings.Contains(strings.ToLower(t.Name), "catch up") {
		return TaskTypeCleanup
	}

	// Planning: explicit planning tags or keywords
	if t.HasTag("planning") || t.HasTag("review") || t.HasTag("brainstorm") ||
		strings.Contains(strings.ToLower(t.Name), "plan") ||
		strings.Contains(strings.ToLower(t.Name), "review") ||
		strings.Contains(strings.ToLower(t.Name), "brainstorm") ||
		strings.Contains(strings.ToLower(t.Name), "outline") {
		return TaskTypePlanning
	}

	// Perpetual Flow: very frequent recurring (every 1-2 days)
	if t.RecurringEveryDays > 0 && t.RecurringEveryDays <= 2 {
		return TaskTypePerpetualFlow
	}

	// Maintenance: recurring with moderate intervals (3-30 days)
	if t.RecurringEveryDays > 0 {
		return TaskTypeMaintenance
	}

	// Deep Work: creation-oriented keywords, or project context
	if t.HasTag("create") || t.HasTag("build") || t.HasTag("write") || t.HasTag("code") ||
		strings.Contains(strings.ToLower(t.Name), "write") ||
		strings.Contains(strings.ToLower(t.Name), "create") ||
		strings.Contains(strings.ToLower(t.Name), "build") ||
		strings.Contains(strings.ToLower(t.Name), "develop") ||
		strings.Contains(strings.ToLower(t.Name), "design") {
		return TaskTypeDeepWork
	}

	// Admin: short operational tasks (default for most single tasks)
	// Indicators: bill, email, call, schedule, pay, order
	if strings.Contains(strings.ToLower(t.Name), "bill") ||
		strings.Contains(strings.ToLower(t.Name), "email") ||
		strings.Contains(strings.ToLower(t.Name), "call") ||
		strings.Contains(strings.ToLower(t.Name), "schedule") ||
		strings.Contains(strings.ToLower(t.Name), "pay") ||
		strings.Contains(strings.ToLower(t.Name), "order") ||
		strings.Contains(strings.ToLower(t.Name), "buy") {
		return TaskTypeAdmin
	}

	// Default to Admin for short, unclassified tasks
	return TaskTypeAdmin
}

// EstimatedSlots returns a rough estimate of how many villager slots this task might consume
// This is a simple heuristic for v0.1
func (t *Task) EstimatedSlots() int {
	taskType := t.InferType()
	
	switch taskType {
	case TaskTypeAdmin, TaskTypeCleanup:
		return 1 // quick tasks
	case TaskTypeMaintenance, TaskTypePerpetualFlow:
		return 1 // routine
	case TaskTypePlanning:
		return 2 // thinking time
	case TaskTypeDeepWork:
		return 3 // focused creation
	default:
		return 1
	}
}

// IsLive returns true if the task is in the live zone and not completed
func (t *Task) IsLive() bool {
	return t.Zone == ZoneLive && !t.Completed
}

// IsOverdue returns true if the task has a deadline and it's passed
func (t *Task) IsOverdue(now time.Time) bool {
	return t.DeadlineAt != nil && now.After(*t.DeadlineAt)
}
